<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Good good study,day day up!">
<meta property="og:type" content="website">
<meta property="og:title" content="寒竹">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="寒竹">
<meta property="og:description" content="Good good study,day day up!">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yiya1989">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>寒竹</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">寒竹</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-thumbtack fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/yiya1989" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/23/containerd-code-learn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiya1989">
      <meta itemprop="description" content="Good good study,day day up!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="寒竹">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
              <span class="post-sticky-flag" title="置顶">
                <i class="fa fa-thumbtack"></i>
              </span>
            <a href="/2022/05/23/containerd-code-learn/" class="post-title-link" itemprop="url">containerd代码走读</a>
        </h2>

        <div class="post-meta">


          
            <i class="fa fa-thumbtack"></i>
            <font color=7D26CD>置顶</font>
            <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-23 15:05:55 / 修改时间：15:31:01" itemprop="dateCreated datePublished" datetime="2022-05-23T15:05:55+08:00">2022-05-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/k8s/containerd/" itemprop="url" rel="index"><span itemprop="name">containerd</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<h1 id="一-containerd官网介绍"><a href="#一-containerd官网介绍" class="headerlink" title="一. containerd官网介绍"></a>一. containerd官网介绍</h1><p>首先是containerd官网，<a target="_blank" rel="noopener" href="https://containerd.io/">https://containerd.io/</a><br>官网有一张containerd架构图，如下<br><img src="https://containerd.io/img/architecture.png" alt="image"><br>关于架构图整体说明，网上有一篇文章【<a target="_blank" rel="noopener" href="https://www.qikqiak.com/post/containerd-usage/">一文搞懂容器运行时 Containerd</a>】写的不错，就直接搬过来了。另外对containerd不太了解的，也可以先看下这篇文章了解下containerd。</p>
<blockquote>
<p>上图是 containerd 官方提供的架构图，可以看出 containerd 采用的也是 C/S 架构，服务端通过 unix domain socket 暴露低层的 gRPC API 接口出去，客户端通过这些 API 管理节点上的容器，每个 containerd 只负责一台机器，Pull 镜像，对容器的操作（启动、停止等），网络，存储都是由 containerd 完成。具体运行容器由 runc 负责，实际上只要是符合 OCI 规范的容器都可以支持。<br>&emsp;<br>为了解耦，containerd 将系统划分成了不同的组件，每个组件都由一个或多个模块协作完成（Core 部分），每一种类型的模块都以插件的形式集成到 Containerd 中，而且插件之间是相互依赖的，例如，上图中的每一个长虚线的方框都表示一种类型的插件，包括 Service Plugin、Metadata Plugin、GC Plugin、Runtime Plugin 等，其中 Service Plugin 又会依赖 Metadata Plugin、GC Plugin 和 Runtime Plugin。每一个小方框都表示一个细分的插件，例如 Metadata Plugin 依赖 Containers Plugin、Content Plugin 等。</p>
</blockquote>
<h1 id="二，containerd组件版本信息"><a href="#二，containerd组件版本信息" class="headerlink" title="二，containerd组件版本信息"></a>二，containerd组件版本信息</h1><p>本文代码分析使用的组件版本如下：</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>版本</th>
<th>下载地址</th>
</tr>
</thead>
<tbody><tr>
<td>contaierd</td>
<td>v1.6.4</td>
<td><a target="_blank" rel="noopener" href="https://github.com/containerd/containerd">https://github.com/containerd/containerd</a></td>
</tr>
<tr>
<td>kubernetes</td>
<td>v1.23.1</td>
<td><a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes">https://github.com/kubernetes/kubernetes</a></td>
</tr>
</tbody></table>
<h1 id="三，containerd代码走读"><a href="#三，containerd代码走读" class="headerlink" title="三，containerd代码走读"></a>三，containerd代码走读</h1><p>主要走读以下几个部分：containerd启动流程，plugin机制说明，容器启动流程。</p>
<h2 id="1-containerd-main-函数"><a href="#1-containerd-main-函数" class="headerlink" title="1. containerd main 函数"></a>1. containerd main 函数</h2><p>入口目录为 containerd/main.go 中 main 函数，默认配置文件 /etc/containerd/config.toml。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	app := command.App()</span><br><span class="line">	if err := app.Run(os.Args); err != nil &#123;</span><br><span class="line">		fmt.Fprintf(os.Stderr, &quot;containerd: %s\n&quot;, err)</span><br><span class="line">		os.Exit(1)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-command-App命令入口"><a href="#2-command-App命令入口" class="headerlink" title="2. command.App命令入口"></a>2. command.App命令入口</h2><p>command.App()，包含三个子命令: <code>configCommand</code>，<code>publishCommand</code>，<code>ociHook</code>。如果不支持子命令，则执行根命令<code>containerd</code>，启动containerd服务，实际为执行<code>server.New(ctx, config)</code>。</p>
<blockquote>
<p><code>DESCRIPTION from cmd/containerd/command/main.go: app.Description</code><br>&emsp;<br>DESCRIPTION<br>&emsp;containerd is a high performance container runtime whose daemon can be started<br>by using this command. If none of the <em>config</em>, <em>publish</em>, or <em>help</em> commands<br>are specified, the default action of the <strong>containerd</strong> command is to start the<br>containerd daemon in the foreground.<br>&emsp;<br>COMMANDS:<br>&emsp;config    information on the containerd config<br>&emsp;publish   binary to publish events to containerd<br>&emsp;oci-hook  provides a base for OCI runtime hooks to allow arguments to be injected.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">func App() *cli.App &#123;</span><br><span class="line">	app := cli.NewApp()</span><br><span class="line">    app.Action = func(context *cli.Context) error &#123;</span><br><span class="line">        ...</span><br><span class="line">		// run server initialization in a goroutine so we don&#x27;t end up blocking important things like SIGTERM handling</span><br><span class="line">		// while the server is initializing.</span><br><span class="line">		// As an example opening the bolt database will block forever if another containerd is already running and containerd</span><br><span class="line">		// will have to be be `kill -9`&#x27;ed to recover.</span><br><span class="line">		chsrv := make(chan srvResp)</span><br><span class="line">		go func() &#123;</span><br><span class="line">			defer close(chsrv)</span><br><span class="line"></span><br><span class="line">			server, err := server.New(ctx, config)</span><br><span class="line">			if err != nil &#123;</span><br><span class="line">				select &#123;</span><br><span class="line">				case chsrv &lt;- srvResp&#123;err: err&#125;:</span><br><span class="line">				case &lt;-ctx.Done():</span><br><span class="line">				&#125;</span><br><span class="line">				return</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Launch as a Windows Service if necessary</span><br><span class="line">			if err := launchService(server, done); err != nil &#123;</span><br><span class="line">				logrus.Fatal(err)</span><br><span class="line">			&#125;</span><br><span class="line">			select &#123;</span><br><span class="line">			case &lt;-ctx.Done():</span><br><span class="line">				server.Stop()</span><br><span class="line">			case chsrv &lt;- srvResp&#123;s: server&#125;:</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-server-New服务启动过程"><a href="#3-server-New服务启动过程" class="headerlink" title="3. server.New服务启动过程"></a>3. server.New服务启动过程</h2><p><code>server.New</code>启动主要就是两件事情：LoadPlugins加载所有的plugin，启动Server启动所支持的grpc/tcp/ttrpc等几种类型的服务。<br>同时在启动Server时，会判断每种plugin是否支持相关Server接口，如果支持则分别追加到相关Server类型中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// New creates and initializes a new containerd server</span><br><span class="line">func New(ctx context.Context, config *srvconfig.Config) (*Server, error) &#123;</span><br><span class="line">    ...</span><br><span class="line">	plugins, err := LoadPlugins(ctx, config)</span><br><span class="line">	...</span><br><span class="line">	var (</span><br><span class="line">		...</span><br><span class="line">		s = &amp;Server&#123;</span><br><span class="line">			grpcServer:  grpcServer,</span><br><span class="line">			tcpServer:   tcpServer,</span><br><span class="line">			ttrpcServer: ttrpcServer,</span><br><span class="line">			config:      config,</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">	)</span><br><span class="line">	...</span><br><span class="line">	for _, p := range plugins &#123;</span><br><span class="line">	    ...</span><br><span class="line">		// check for grpc services that should be registered with the server</span><br><span class="line">		if src, ok := instance.(grpcService); ok &#123;</span><br><span class="line">			grpcServices = append(grpcServices, src)</span><br><span class="line">		&#125;</span><br><span class="line">		if src, ok := instance.(ttrpcService); ok &#123;</span><br><span class="line">			ttrpcServices = append(ttrpcServices, src)</span><br><span class="line">		&#125;</span><br><span class="line">		if service, ok := instance.(tcpService); ok &#123;</span><br><span class="line">			tcpServices = append(tcpServices, service)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		s.plugins = append(s.plugins, result)</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">	return s, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-加载插件LoadPlugins"><a href="#3-1-加载插件LoadPlugins" class="headerlink" title="3.1 加载插件LoadPlugins"></a>3.1 加载插件LoadPlugins</h3><p>从默认配置文件中取PluginDir配置，如果没有则拼接Root+plugins。<br>config.Root默认值为<code>/var/lib/containerd</code>。默认值常量文件为<code>defaults/defaults_unix.go</code>。<br>plugin加载完后，除了禁用的插件，在<code>plugin.Graph</code>函数中按照依赖关系返回一个有序的插件列表。<br>这里有两个特殊的插件<code>ContentPlugin</code>和<code>MetadataPlugin</code>，是在<code>LoadPlugins</code>注册的，为什么要在这里注册，我也不太了解，欢迎留言告知。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// LoadPlugins loads all plugins into containerd and generates an ordered graph</span><br><span class="line">// of all plugins.</span><br><span class="line">func LoadPlugins(ctx context.Context, config *srvconfig.Config) ([]*plugin.Registration, error) &#123;</span><br><span class="line">	// load all plugins into containerd</span><br><span class="line">	path := config.PluginDir</span><br><span class="line">	if path == &quot;&quot; &#123;</span><br><span class="line">		path = filepath.Join(config.Root, &quot;plugins&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	if err := plugin.Load(path); err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">		// load additional plugins that don&#x27;t automatically register themselves</span><br><span class="line">	plugin.Register(&amp;plugin.Registration&#123;</span><br><span class="line">		Type: plugin.ContentPlugin,</span><br><span class="line">		ID:   &quot;content&quot;,</span><br><span class="line">		InitFn: func(ic *plugin.InitContext) (interface&#123;&#125;, error) &#123;</span><br><span class="line">			ic.Meta.Exports[&quot;root&quot;] = ic.Root</span><br><span class="line">			return local.NewStore(ic.Root)</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">	plugin.Register(&amp;plugin.Registration&#123;</span><br><span class="line">		Type: plugin.MetadataPlugin,</span><br><span class="line">		ID:   &quot;bolt&quot;,</span><br><span class="line">		Requires: []plugin.Type&#123;</span><br><span class="line">			plugin.ContentPlugin,</span><br><span class="line">			plugin.SnapshotPlugin,</span><br><span class="line">		&#125;,</span><br><span class="line">		Config: &amp;srvconfig.BoltConfig&#123;</span><br><span class="line">			ContentSharingPolicy: srvconfig.SharingPolicyShared,</span><br><span class="line">		&#125;,</span><br><span class="line">		InitFn: func(ic *plugin.InitContext) (interface&#123;&#125;, error) &#123;</span><br><span class="line">		    ...</span><br><span class="line">			mdb := metadata.NewDB(db, cs.(content.Store), snapshotters, dbopts...)</span><br><span class="line">			if err := mdb.Init(ic.Context); err != nil &#123;</span><br><span class="line">				return nil, err</span><br><span class="line">			&#125;</span><br><span class="line">			return mdb, nil</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	// return the ordered graph for plugins</span><br><span class="line">	return plugin.Graph(filter(config.DisabledPlugins)), nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-2-插件初始化，Server加载"><a href="#3-2-插件初始化，Server加载" class="headerlink" title="3.2 插件初始化，Server加载"></a>3.2 插件初始化，Server加载</h3><p>如上所属，<code>LoadPlugins</code>是负责找出所有可用的插件，并按照依赖关系排序。<br>但插件初始化，是在<code>server.New</code>函数中完成的，且初始化时同时判断该插件是否支持Server对外提供服务，如果支持则同时追加到匹配的Server列表中。<br>contanerd支持配置<code>RequiredPlugins</code>设置必须加载的插件列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">for _, p := range plugins &#123;</span><br><span class="line">    ...</span><br><span class="line">	result := p.Init(initContext)</span><br><span class="line">       ...</span><br><span class="line">	instance, err := result.Instance()</span><br><span class="line">       ...</span><br><span class="line">	// check for grpc services that should be registered with the server</span><br><span class="line">	if src, ok := instance.(grpcService); ok &#123;</span><br><span class="line">		grpcServices = append(grpcServices, src)</span><br><span class="line">	&#125;</span><br><span class="line">	if src, ok := instance.(ttrpcService); ok &#123;</span><br><span class="line">		ttrpcServices = append(ttrpcServices, src)</span><br><span class="line">	&#125;</span><br><span class="line">	if service, ok := instance.(tcpService); ok &#123;</span><br><span class="line">		tcpServices = append(tcpServices, service)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s.plugins = append(s.plugins, result)</span><br><span class="line">&#125;</span><br><span class="line">if len(required) != 0 &#123;</span><br><span class="line">	var missing []string</span><br><span class="line">	for id := range required &#123;</span><br><span class="line">		missing = append(missing, id)</span><br><span class="line">	&#125;</span><br><span class="line">	return nil, fmt.Errorf(&quot;required plugin %s not included&quot;, missing)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// register services after all plugins have been initialized</span><br><span class="line">for _, service := range grpcServices &#123;</span><br><span class="line">	if err := service.Register(grpcServer); err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">for _, service := range ttrpcServices &#123;</span><br><span class="line">	if err := service.RegisterTTRPC(ttrpcServer); err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">for _, service := range tcpServices &#123;</span><br><span class="line">	if err := service.RegisterTCP(tcpServer); err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-Server真正初始化"><a href="#3-3-Server真正初始化" class="headerlink" title="3.3 Server真正初始化"></a>3.3 Server真正初始化</h3><p>上一步或别获取了grpcServer/ttrpcServer/tcpServer几种Server类型，现在在<code>server.New</code>中根据config配置，分别通过<code>serve</code>函数分别对其进行初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// run server initialization in a goroutine so we don&#x27;t end up blocking important things like SIGTERM handling</span><br><span class="line">// while the server is initializing.</span><br><span class="line">// As an example opening the bolt database will block forever if another containerd is already running and containerd</span><br><span class="line">// will have to be be `kill -9`&#x27;ed to recover.</span><br><span class="line">go func() &#123;</span><br><span class="line">    ...</span><br><span class="line">	server, err := server.New(ctx, config)</span><br><span class="line">	...</span><br><span class="line">	select &#123;</span><br><span class="line">	case &lt;-ctx.Done():</span><br><span class="line">		server.Stop()</span><br><span class="line">	case chsrv &lt;- srvResp&#123;s: server&#125;:</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">var server *server.Server</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-ctx.Done():</span><br><span class="line">	return ctx.Err()</span><br><span class="line">case r := &lt;-chsrv:</span><br><span class="line">	if r.err != nil &#123;</span><br><span class="line">		return r.err</span><br><span class="line">	&#125;</span><br><span class="line">	server = r.s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// We don&#x27;t send the server down serverC directly in the goroutine above because we need it lower down.</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-ctx.Done():</span><br><span class="line">	return ctx.Err()</span><br><span class="line">case serverC &lt;- server:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">if config.Metrics.Address != &quot;&quot; &#123;</span><br><span class="line">	l, err := net.Listen(&quot;tcp&quot;, config.Metrics.Address)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return fmt.Errorf(&quot;failed to get listener for metrics endpoint: %w&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	serve(ctx, l, server.ServeMetrics)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">serve(ctx, tl, server.ServeTTRPC)</span><br><span class="line"></span><br><span class="line">if config.GRPC.TCPAddress != &quot;&quot; &#123;</span><br><span class="line">	l, err := net.Listen(&quot;tcp&quot;, config.GRPC.TCPAddress)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return fmt.Errorf(&quot;failed to get listener for TCP grpc endpoint: %w&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	serve(ctx, l, server.ServeTCP)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">serve(ctx, l, server.ServeGRPC)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-plugin机制说明"><a href="#4-plugin机制说明" class="headerlink" title="4. plugin机制说明"></a>4. plugin机制说明</h2><p>以<code>cri</code>为例，简单说明containerd的插件机制，cri代码路径为<code>pkg/cri/cri.go</code>。</p>
<h3 id="4-1-插件注册函数"><a href="#4-1-插件注册函数" class="headerlink" title="4.1 插件注册函数"></a>4.1 插件注册函数</h3><p>插件注册统一都使用<code>    plugin.Register(&amp;plugin.Registration&#123;&#125;)</code>这种形式。<br><code>Type</code>为插件类型，<code>ID</code>为插件名称，<code>Requires</code>为本插件依赖的其他插件，<code>Config</code>为该插件对应的配置，<code>InitFn</code>为插件初始化函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Register CRI service plugin</span><br><span class="line">func init() &#123;</span><br><span class="line">	config := criconfig.DefaultConfig()</span><br><span class="line">	plugin.Register(&amp;plugin.Registration&#123;</span><br><span class="line">		Type:   plugin.GRPCPlugin,</span><br><span class="line">		ID:     &quot;cri&quot;,</span><br><span class="line">		Config: &amp;config,</span><br><span class="line">		Requires: []plugin.Type&#123;</span><br><span class="line">			plugin.EventPlugin,</span><br><span class="line">			plugin.ServicePlugin,</span><br><span class="line">		&#125;,</span><br><span class="line">		InitFn: initCRIService,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-注册插件初始化函数"><a href="#4-2-注册插件初始化函数" class="headerlink" title="4.2 注册插件初始化函数"></a>4.2 注册插件初始化函数</h3><p><code>cri</code>插件的初始化函数为<code>initCRIService</code>。该函数实际返回的为<code>criService</code>的结构体，可以看到该结构体同时具备<code>Register</code>和<code>RegisterTCP</code>，所以最后<code>cri</code>会同时在grpcServer/tcpServer中提供服务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func initCRIService(ic *plugin.InitContext) (interface&#123;&#125;, error) &#123;</span><br><span class="line">    ...</span><br><span class="line">    s, err := server.NewCRIService(c, client)</span><br><span class="line">	...</span><br><span class="line">	return s, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// NewCRIService returns a new instance of CRIService</span><br><span class="line">func NewCRIService(config criconfig.Config, client *containerd.Client) (CRIService, error) &#123;</span><br><span class="line">	var err error</span><br><span class="line">	labels := label.NewStore()</span><br><span class="line">	c := &amp;criService&#123;</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	return c, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Register registers all required services onto a specific grpc server.</span><br><span class="line">// This is used by containerd cri plugin.</span><br><span class="line">func (c *criService) Register(s *grpc.Server) error &#123;</span><br><span class="line">	return c.register(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// RegisterTCP register all required services onto a GRPC server on TCP.</span><br><span class="line">// This is used by containerd CRI plugin.</span><br><span class="line">func (c *criService) RegisterTCP(s *grpc.Server) error &#123;</span><br><span class="line">	if !c.config.DisableTCPService &#123;</span><br><span class="line">		return c.register(s)</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-插件初始化"><a href="#4-3-插件初始化" class="headerlink" title="4.3 插件初始化"></a>4.3 插件初始化</h3><p>上面只是注册了<code>InitFn</code>函数，那么到底是在哪里，什么时候初始化的？<br>插件的初始化，还是在上面的<code>server.New</code>函数中。<br>先初始化一个<code>initContext := plugin.NewContext</code>，再执行<code>result := p.Init(initContext)</code>初始化plugin，最后通过<code>instance, err := result.Instance()</code>获取该plugin的实例，<code>result</code>即该plugin对应的初始化后的对象。<br>如果plugin支持参数配置，初始化时还会使用containerd的配置文件覆盖plugin的默认配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// Init the registered plugin</span><br><span class="line">func (r *Registration) Init(ic *InitContext) *Plugin &#123;</span><br><span class="line">	p, err := r.InitFn(ic)</span><br><span class="line">	return &amp;Plugin&#123;</span><br><span class="line">		Registration: r,</span><br><span class="line">		Config:       ic.Config,</span><br><span class="line">		Meta:         ic.Meta,</span><br><span class="line">		instance:     p,</span><br><span class="line">		err:          err,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func New(ctx context.Context, config *srvconfig.Config) (*Server, error) &#123;</span><br><span class="line">    ...</span><br><span class="line">	plugins, err := LoadPlugins(ctx, config)</span><br><span class="line">	...</span><br><span class="line">	for _, p := range plugins &#123;</span><br><span class="line">	    ...</span><br><span class="line">		initContext := plugin.NewContext(</span><br><span class="line">			ctx,</span><br><span class="line">			p,</span><br><span class="line">			initialized,</span><br><span class="line">			config.Root,</span><br><span class="line">			config.State,</span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line">		// load the plugin specific configuration if it is provided</span><br><span class="line">		if p.Config != nil &#123;</span><br><span class="line">			pc, err := config.Decode(p)</span><br><span class="line">			if err != nil &#123;</span><br><span class="line">				return nil, err</span><br><span class="line">			&#125;</span><br><span class="line">			initContext.Config = pc</span><br><span class="line">		&#125;</span><br><span class="line">		result := p.Init(initContext)</span><br><span class="line">		if err := initialized.Add(result); err != nil &#123;</span><br><span class="line">			return nil, fmt.Errorf(&quot;could not add plugin result to plugin set: %w&quot;, err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		instance, err := result.Instance()</span><br><span class="line">        ...</span><br><span class="line">		s.plugins = append(s.plugins, result)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-4-如何使用插件"><a href="#4-4-如何使用插件" class="headerlink" title="4.4 如何使用插件"></a>4.4 如何使用插件</h3><p>如最上面所说，containerd采用了模块化的设计，每个模块写自己的代码，并通过<code>Requires</code>指定自己依赖的plugin。并且提供了grpcServer/ttrpcServer/tcpServer几种Server类型，可以提供Server服务。<br>所以有两种方式使用插件提供的功能：</p>
<ol>
<li>外部程序通过GRPC、TCP、TTPGC访问containerd<br>插件提供了一种或几种以下<code>interface</code>：<code>Register(*grpc.Server) error</code>、<code>RegisterTCP(*grpc.Server) error</code>、<code>RegisterTTRPC(*ttrpc.Server) error</code>，则containerd会相应的提供响应的GRPC、TCP、TTPGC服务，可以在程序外通过GRPC、TCP、TTPGC调用contanerd的plugin功能。</li>
<li>containerd内部相互访问<br>还是以<code>cri</code>为例，<code>cri</code>依赖<code>plugin.EventPlugin</code>和<code>plugin.ServicePlugin</code>,则在<code>cri</code>初始化函数中通过<code>ic.GetByType</code>获取所有对应的plugins，再通过<code>p.Instance()</code>获取对应的plugin实例</li>
<li>其实阅读containerd代码，发现plugin内部也存在通过GRPC接口相互访问的用法。比如<code>pkg/cri/server/container_create.go: c.client.NewContainer</code>对<code>client.go:297 c.ContainerService().Create</code>的访问，该用法也会在<code>CreateContainer</code>部分中提到。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// getServicesOpts get service options from plugin context.</span><br><span class="line">func getServicesOpts(ic *plugin.InitContext) ([]containerd.ServicesOpt, error) &#123;</span><br><span class="line">	plugins, err := ic.GetByType(plugin.ServicePlugin)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, fmt.Errorf(&quot;failed to get service plugin: %w&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ep, err := ic.Get(plugin.EventPlugin)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, fmt.Errorf(&quot;failed to get event plugin: %w&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	&#123;</span><br><span class="line">		p := plugins[s]</span><br><span class="line">		if p == nil &#123;</span><br><span class="line">			return nil, fmt.Errorf(&quot;service %q not found&quot;, s)</span><br><span class="line">		&#125;</span><br><span class="line">		i, err := p.Instance()</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			return nil, fmt.Errorf(&quot;failed to get instance of service %q: %w&quot;, s, err)</span><br><span class="line">		&#125;</span><br><span class="line">		if i == nil &#123;</span><br><span class="line">			return nil, fmt.Errorf(&quot;instance of service %q not found&quot;, s)</span><br><span class="line">		&#125;</span><br><span class="line">		opts = append(opts, fn(i))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="5-容器启动流程"><a href="#5-容器启动流程" class="headerlink" title="5. 容器启动流程"></a>5. 容器启动流程</h2><h3 id="5-1-kubelet与containerd交互接口"><a href="#5-1-kubelet与containerd交互接口" class="headerlink" title="5.1 kubelet与containerd交互接口"></a>5.1 kubelet与containerd交互接口</h3><h4 id="5-1-1-kubelet启动"><a href="#5-1-1-kubelet启动" class="headerlink" title="5.1.1 kubelet启动"></a>5.1.1 kubelet启动</h4><p>kubelet中<code>PreInitRuntimeService</code>函数会初始化<code>NewRemoteRuntimeService</code>和<code>RemoteImageService</code>。<br>使用containerd场景，<code>--container-runtime-endpoint</code>会配置为containerd的socket路径，可在contanerd配置文件中配置，默认为<code>/run/containerd/containerd.sock</code>。<br><code>--image-service-endpoint</code>支持单独配置，不配置的情况话，则取<code>--container-runtime-endpoint</code>的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">cmd/kubelet/kubelet.go:39 -&gt; main()  </span><br><span class="line">cmd/kubelet/kubelet.go:40 -&gt; command := app.NewKubeletCommand()</span><br><span class="line">cmd/kubelet/app/server.go:301 -&gt; Run(ctx, kubeletServer, kubeletDeps, utilfeature.DefaultFeatureGate)</span><br><span class="line">cmd/kubelet/app/server.go:450 -&gt; run(ctx, s, kubeDeps, featureGate)</span><br><span class="line">cmd/kubelet/app/server.go:802 -&gt; err = kubelet.PreInitRuntimeService(&amp;s.KubeletConfiguration,</span><br><span class="line">==&gt;</span><br><span class="line"></span><br><span class="line">// PreInitRuntimeService will init runtime service before RunKubelet.</span><br><span class="line">func PreInitRuntimeService(kubeCfg *kubeletconfiginternal.KubeletConfiguration,</span><br><span class="line">    ...</span><br><span class="line">	var err error</span><br><span class="line">	if kubeDeps.RemoteRuntimeService, err = remote.NewRemoteRuntimeService(remoteRuntimeEndpoint, kubeCfg.RuntimeRequestTimeout.Duration); err != nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">	if kubeDeps.RemoteImageService, err = remote.NewRemoteImageService(remoteImageEndpoint, kubeCfg.RuntimeRequestTimeout.Duration); err != nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	kubeDeps.useLegacyCadvisorStats = cadvisor.UsingLegacyCadvisorStats(containerRuntime, remoteRuntimeEndpoint)</span><br><span class="line"></span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-1-2-NewRemoteRuntimeService初始化"><a href="#5-1-2-NewRemoteRuntimeService初始化" class="headerlink" title="5.1.2 NewRemoteRuntimeService初始化"></a>5.1.2 NewRemoteRuntimeService初始化</h4><p>以<code>NewRemoteRuntimeService</code>为例，会初始化一个<code>remoteRuntimeService</code>的struct，并会尝试探测当前的<code>RemoteRuntimeService</code>是使用的什么版本，根据不同的版本，匹配不同的API。<br>如下示例，执行<code>CreateContainer</code>时，会检查根绝版本不同分别执行<code>r.createContainerV1</code>和<code>r.createContainerV1alpha2</code>。当前containerd版本使用的是<code>v1alpha2</code>版本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// NewRemoteRuntimeService creates a new internalapi.RuntimeService.</span><br><span class="line">func NewRemoteRuntimeService(endpoint string, connectionTimeout time.Duration) (internalapi.RuntimeService, error) &#123;</span><br><span class="line">    ...</span><br><span class="line">	service := &amp;remoteRuntimeService&#123;</span><br><span class="line">		timeout:      connectionTimeout,</span><br><span class="line">		logReduction: logreduction.NewLogReduction(identicalErrorDelay),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if err := service.determineAPIVersion(conn); err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return service, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// CreateContainer creates a new container in the specified PodSandbox.</span><br><span class="line">func (r *remoteRuntimeService) CreateContainer(podSandBoxID string, config *runtimeapi.ContainerConfig, sandboxConfig *runtimeapi.PodSandboxConfig) (string, error) &#123;</span><br><span class="line">	klog.V(10).InfoS(&quot;[RemoteRuntimeService] CreateContainer&quot;, &quot;podSandboxID&quot;, podSandBoxID, &quot;timeout&quot;, r.timeout)</span><br><span class="line">	ctx, cancel := getContextWithTimeout(r.timeout)</span><br><span class="line">	defer cancel()</span><br><span class="line"></span><br><span class="line">	if r.useV1API() &#123;</span><br><span class="line">		return r.createContainerV1(ctx, podSandBoxID, config, sandboxConfig)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return r.createContainerV1alpha2(ctx, podSandBoxID, config, sandboxConfig)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-1-3-CreateContainer分析"><a href="#5-1-3-CreateContainer分析" class="headerlink" title="5.1.3 CreateContainer分析"></a>5.1.3 CreateContainer分析</h4><p>继续以<code>CreateContainer -&gt; r.createContainerV1alpha2</code>为例，<code>runtimeClientV1alpha2</code>通过<code> runtimeapiV1alpha2.NewRuntimeServiceClient</code>初始化，返回<code>v1alpha2</code>版本的<code>runtimeServiceClient</code>。<br>在执行<code>CreateContainer</code>时，实际是向containerd的<code>/runtime.v1alpha2.RuntimeService/CreateContainer</code>发起RPC请求。其余函数也是一样的逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// determineAPIVersion tries to connect to the remote runtime by using the</span><br><span class="line">// highest available API version.</span><br><span class="line">func (r *remoteRuntimeService) determineAPIVersion(conn *grpc.ClientConn) error &#123;</span><br><span class="line">    ...</span><br><span class="line">	klog.V(4).InfoS(&quot;Finding the CRI API runtime version&quot;)</span><br><span class="line">	r.runtimeClient = runtimeapi.NewRuntimeServiceClient(conn)</span><br><span class="line"></span><br><span class="line">	if _, err := r.runtimeClient.Version(ctx, &amp;runtimeapi.VersionRequest&#123;&#125;); err == nil &#123;</span><br><span class="line">		klog.V(2).InfoS(&quot;Using CRI v1 runtime API&quot;)</span><br><span class="line"></span><br><span class="line">	&#125; else if status.Code(err) == codes.Unimplemented &#123;</span><br><span class="line">		klog.V(2).InfoS(&quot;Falling back to CRI v1alpha2 runtime API (deprecated)&quot;)</span><br><span class="line">		r.runtimeClientV1alpha2 = runtimeapiV1alpha2.NewRuntimeServiceClient(conn)</span><br><span class="line"></span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return fmt.Errorf(&quot;unable to determine runtime API version: %w&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (r *remoteRuntimeService) createContainerV1alpha2(ctx context.Context, podSandBoxID string, config *runtimeapi.ContainerConfig, sandboxConfig *runtimeapi.PodSandboxConfig) (string, error) &#123;</span><br><span class="line">	resp, err := r.runtimeClientV1alpha2.CreateContainer(ctx, ...)</span><br><span class="line">	...</span><br><span class="line">	return resp.ContainerId, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *runtimeServiceClient) CreateContainer(ctx context.Context, in *CreateContainerRequest, opts ...grpc.CallOption) (*CreateContainerResponse, error) &#123;</span><br><span class="line">	out := new(CreateContainerResponse)</span><br><span class="line">	err := c.cc.Invoke(ctx, &quot;/runtime.v1alpha2.RuntimeService/CreateContainer&quot;, in, out, opts...)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	return out, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-1-3-contaierd接收处理逻辑"><a href="#5-1-3-contaierd接收处理逻辑" class="headerlink" title="5.1.3 contaierd接收处理逻辑"></a>5.1.3 contaierd接收处理逻辑</h4><p><code>CreateContainer</code>接口是在containerd的<code>cri</code>中提供的，还是从<code>cri</code>的启动入口。<br><code>pkg/cri/cri.go</code>的<code>init()</code>函数中<code>plugin.Register</code>注册<code>cri</code>的plugin，然后在containerd启动时在<code>server.New</code>执行了<code>cri</code>的初始化，并且判定<code>cri</code>返回的<code>criService</code>存在<code>interface&#123;&#125;: Register(s *grpc.Server) error</code>，在<code>server.New</code>启动Server时，将<code>cri</code>的GRPC服务一起加载启动了。<br>所以containerd就能在GRPC接口上，接收并转发给<code>cri</code>处理相关的逻辑了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// Register CRI service plugin</span><br><span class="line">func init() &#123;</span><br><span class="line">	config := criconfig.DefaultConfig()</span><br><span class="line">	plugin.Register(&amp;plugin.Registration&#123;</span><br><span class="line">		...</span><br><span class="line">		InitFn: initCRIService,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func initCRIService(ic *plugin.InitContext) (interface&#123;&#125;, error) &#123;</span><br><span class="line">    ...</span><br><span class="line">	s, err := server.NewCRIService(c, client)</span><br><span class="line">    ...</span><br><span class="line">	return s, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// NewCRIService returns a new instance of CRIService</span><br><span class="line">func NewCRIService(config criconfig.Config, client *containerd.Client) (CRIService, error) &#123;</span><br><span class="line">    ...</span><br><span class="line">	c := &amp;criService&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">	return c, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Register registers all required services onto a specific grpc server.</span><br><span class="line">// This is used by containerd cri plugin.</span><br><span class="line">func (c *criService) Register(s *grpc.Server) error &#123;</span><br><span class="line">	return c.register(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// RegisterTCP register all required services onto a GRPC server on TCP.</span><br><span class="line">// This is used by containerd CRI plugin.</span><br><span class="line">func (c *criService) RegisterTCP(s *grpc.Server) error &#123;</span><br><span class="line">	if !c.config.DisableTCPService &#123;</span><br><span class="line">		return c.register(s)</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// CRIService is the interface implement CRI remote service server.</span><br><span class="line">type CRIService interface &#123;</span><br><span class="line">	Run() error</span><br><span class="line">	// io.Closer is used by containerd to gracefully stop cri service.</span><br><span class="line">	io.Closer</span><br><span class="line">	Register(*grpc.Server) error</span><br><span class="line">	grpcServices</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// grpcServices are all the grpc services provided by cri containerd.</span><br><span class="line">type grpcServices interface &#123;</span><br><span class="line">	runtime.RuntimeServiceServer</span><br><span class="line">	runtime.ImageServiceServer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-1-4-cri中最终功能实现函数解析"><a href="#5-1-4-cri中最终功能实现函数解析" class="headerlink" title="5.1.4 cri中最终功能实现函数解析"></a>5.1.4 cri中最终功能实现函数解析</h4><p>可以看到，<code>Register(s *grpc.Server)</code>最终执行到了<code>func (c *criService) register(s *grpc.Server) error</code>函数，并注册了<code>v1</code>和<code>v1alpha</code>的<code>RuntimeServiceServer</code>和<code>ImageServiceServer</code>。<br>并且可以确认，从<code>kubelet</code>发出的<code>v1alpha</code>的<code>CreateContainer</code>消息，最终是发给了<code>newInstrumentedAlphaService(c)</code>生产的struct：<code>instrumentedAlphaService.CreateContainer</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func (c *criService) register(s *grpc.Server) error &#123;</span><br><span class="line">	instrumented := newInstrumentedService(c)</span><br><span class="line">	runtime.RegisterRuntimeServiceServer(s, instrumented)</span><br><span class="line">	runtime.RegisterImageServiceServer(s, instrumented)</span><br><span class="line">	instrumentedAlpha := newInstrumentedAlphaService(c)</span><br><span class="line">	runtime_alpha.RegisterRuntimeServiceServer(s, instrumentedAlpha)</span><br><span class="line">	runtime_alpha.RegisterImageServiceServer(s, instrumentedAlpha)</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func newInstrumentedAlphaService(c *criService) grpcAlphaServices &#123;</span><br><span class="line">	return &amp;instrumentedAlphaService&#123;c: c&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (in *instrumentedAlphaService) CreateContainer(ctx context.Context, r *runtime_alpha.CreateContainerRequest) (res *runtime_alpha.CreateContainerResponse, err error) &#123;</span><br><span class="line">    ...</span><br><span class="line">	v1res, err = in.c.CreateContainer(ctrdutil.WithNamespace(ctx), &amp;v1r)</span><br><span class="line">	...</span><br><span class="line">	return res, errdefs.ToGRPC(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-2-kubelet创建pod流程"><a href="#5-2-kubelet创建pod流程" class="headerlink" title="5.2 kubelet创建pod流程"></a>5.2 kubelet创建pod流程</h3><p>本文主要分析containerd代码，该部分仅做简单说明，后续再补充。<br>大致就是新创建一个sandbox作为pod的壳，再在sandbox中创建并执行initContainer，最后创建container。<br>下面这段代码是<code>kubelet</code>中<code>startContainer</code>启动容器的示例，主要操作为以下四步：</p>
<ul>
<li>拉取镜像</li>
<li>创建容器</li>
<li>启动容器</li>
<li>执行启动后的hook</li>
</ul>
<p>这里我们继续分析这两步操作对应的containerd的<code>CreateContaner</code>和<code>StartContainer</code>流程。这两部分分析，我们都继续使用<code>v1alpha2</code>版本代码作为示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//pkg/kubelet/kuberuntime/kuberuntime_container.go:173</span><br><span class="line"></span><br><span class="line">// startContainer starts a container and returns a message indicates why it is failed on error.</span><br><span class="line">// It starts the container through the following steps:</span><br><span class="line">// * pull the image</span><br><span class="line">// * create the container</span><br><span class="line">// * start the container</span><br><span class="line">// * run the post start lifecycle hooks (if applicable)</span><br><span class="line">func (m *kubeGenericRuntimeManager) startContainer(podSandboxID string, podSandboxConfig *runtimeapi.PodSandboxConfig, spec *startSpec, pod *v1.Pod, podStatus *kubecontainer.PodStatus, pullSecrets []v1.Secret, podIP string, podIPs []string) (string, error) &#123;</span><br><span class="line">  container := spec.container</span><br><span class="line"></span><br><span class="line">  // Step 1: pull the image.</span><br><span class="line">  imageRef, msg, err := m.imagePuller.EnsureImageExists(pod, container, pullSecrets, podSandboxConfig)</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  // Step 2: create the container.</span><br><span class="line">  // For a new container, the RestartCount should be 0</span><br><span class="line">  containerID, err := m.runtimeService.CreateContainer(podSandboxID, containerConfig, podSandboxConfig)</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  // Step 3: start the container.</span><br><span class="line">  err = m.runtimeService.StartContainer(containerID)</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  // Step 4: execute the post start hook.</span><br><span class="line">    msg, handlerErr := m.runner.Run(kubeContainerID, pod, container, container.Lifecycle.PostStart)</span><br><span class="line">    ...</span><br><span class="line">  return &quot;&quot;, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="5-3-cri的CreateContainer解析"><a href="#5-3-cri的CreateContainer解析" class="headerlink" title="5.3 cri的CreateContainer解析"></a>5.3 cri的CreateContainer解析</h3><h4 id="5-3-1-instrumentedAlphaService-CreateContainer"><a href="#5-3-1-instrumentedAlphaService-CreateContainer" class="headerlink" title="5.3.1 instrumentedAlphaService.CreateContainer"></a>5.3.1 <code>instrumentedAlphaService.CreateContainer</code></h4><p><code>instrumentedAlphaService.CreateContainer</code>中的<code>in.c</code>就是<code>criService</code>，即最终执行的是<code>criService.CreateContainer</code>函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type instrumentedAlphaService struct &#123;</span><br><span class="line">	c *criService</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (in *instrumentedAlphaService) CreateContainer(ctx context.Context, r *runtime_alpha.CreateContainerRequest) (res *runtime_alpha.CreateContainerResponse, err error) &#123;</span><br><span class="line">	...</span><br><span class="line">	var v1res *runtime.CreateContainerResponse</span><br><span class="line">	v1res, err = in.c.CreateContainer(ctrdutil.WithNamespace(ctx), &amp;v1r)</span><br><span class="line">	...</span><br><span class="line">	return res, errdefs.ToGRPC(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-2-criService-CreateContainer"><a href="#5-3-2-criService-CreateContainer" class="headerlink" title="5.3.2 criService.CreateContainer"></a>5.3.2 <code>criService.CreateContainer</code></h4><p><code>criService.CreateContainer</code>中的代码逻辑很多，涉及很多生成OCI-SPEC配置的逻辑，但本文最重要的目的是梳理从kubelet到containerd的主流程，到了大家级别大家应该都能看的懂，所以这里依然重点讲几个关键点。<br>该函数，重点关注<code>c.client.NewContainer</code>和<code>c.containerStore.Add(container)</code>。<br><code>c.client.NewContainer</code>是创建本地的local-DB，<code>c.containerStore</code>是针对local-DB做缓存，方便下次根据containerId获取对应的local-DB信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// CreateContainer creates a new container in the given PodSandbox.</span><br><span class="line">func (c *criService) CreateContainer(ctx context.Context, r *runtime.CreateContainerRequest) (_ *runtime.CreateContainerResponse, retErr error) &#123;</span><br><span class="line">    ...</span><br><span class="line">	var cntr containerd.Container</span><br><span class="line">	if cntr, err = c.client.NewContainer(ctx, id, opts...); err != nil &#123;</span><br><span class="line">		return nil, fmt.Errorf(&quot;failed to create containerd container: %w&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">	container, err := containerstore.NewContainer(meta,</span><br><span class="line">		containerstore.WithStatus(status, containerRootDir),</span><br><span class="line">		containerstore.WithContainer(cntr),</span><br><span class="line">		containerstore.WithContainerIO(containerIO),</span><br><span class="line">	)</span><br><span class="line">    ...</span><br><span class="line">	// Add container into container store.</span><br><span class="line">	if err := c.containerStore.Add(container); err != nil &#123;</span><br><span class="line">		return nil, fmt.Errorf(&quot;failed to add container %q into store: %w&quot;, id, err)</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">	return &amp;runtime.CreateContainerResponse&#123;ContainerId: id&#125;, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-2-c-client-NewContainer"><a href="#5-3-2-c-client-NewContainer" class="headerlink" title="5.3.2 c.client.NewContainer"></a>5.3.2 <code>c.client.NewContainer</code></h4><p>这里就涉及到了contaierd的另一种用法，containerd内部的plugin调用另一个plugin的API。<br>这里的<code>c.ContainerService().Create</code>实际为<code>&quot;/containerd.services.containers.v1.Containers/Create&quot;</code>对应的GRPC服务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// NewContainer will create a new container with the provided id.</span><br><span class="line">// The id must be unique within the namespace.</span><br><span class="line">func (c *Client) NewContainer(ctx context.Context, id string, opts ...NewContainerOpts) (Container, error) &#123;</span><br><span class="line">	...</span><br><span class="line">	container := containers.Container&#123;</span><br><span class="line">		ID: id,</span><br><span class="line">		Runtime: containers.RuntimeInfo&#123;</span><br><span class="line">			Name: c.runtime,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">	r, err := c.ContainerService().Create(ctx, container)</span><br><span class="line">	...</span><br><span class="line">	return containerFromRecord(c, r), nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ContainerService returns the underlying container Store</span><br><span class="line">func (c *Client) ContainerService() containers.Store &#123;</span><br><span class="line">	if c.containerStore != nil &#123;</span><br><span class="line">		return c.containerStore</span><br><span class="line">	&#125;</span><br><span class="line">	c.connMu.Lock()</span><br><span class="line">	defer c.connMu.Unlock()</span><br><span class="line">	return NewRemoteContainerStore(containersapi.NewContainersClient(c.conn))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (c *containersClient) Create(ctx context.Context, in *CreateContainerRequest, opts ...grpc.CallOption) (*CreateContainerResponse, error) &#123;</span><br><span class="line">	out := new(CreateContainerResponse)</span><br><span class="line">	err := c.cc.Invoke(ctx, &quot;/containerd.services.containers.v1.Containers/Create&quot;, in, out, opts...)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	return out, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-3-containersplugin"><a href="#5-3-3-containersplugin" class="headerlink" title="5.3.3 containersplugin"></a>5.3.3 <code>containers</code>plugin</h4><p>而该服务，则正好对应<code>containerd.services.containers.v1-&gt;Containers-&gt;Create</code>，亦即<code>Type: plugin.GRPCPlugin</code> 和 <code>ID:   &quot;containers&quot;</code>对应的plugin。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">func init() &#123;</span><br><span class="line">	plugin.Register(&amp;plugin.Registration&#123;</span><br><span class="line">		Type: plugin.GRPCPlugin,</span><br><span class="line">		ID:   &quot;containers&quot;,</span><br><span class="line">		Requires: []plugin.Type&#123;</span><br><span class="line">			plugin.ServicePlugin,</span><br><span class="line">		&#125;,</span><br><span class="line">		InitFn: func(ic *plugin.InitContext) (interface&#123;&#125;, error) &#123;</span><br><span class="line">		    ...</span><br><span class="line">			return &amp;service&#123;local: i.(api.ContainersClient)&#125;, nil</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type service struct &#123;</span><br><span class="line">	local api.ContainersClient</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var _ api.ContainersServer = &amp;service&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (s *service) Register(server *grpc.Server) error &#123;</span><br><span class="line">	api.RegisterContainersServer(server, s)</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func _Containers_Create_Handler(srv interface&#123;&#125;, ctx context.Context, dec func(interface&#123;&#125;) error, interceptor grpc.UnaryServerInterceptor) (interface&#123;&#125;, error) &#123;</span><br><span class="line">    ...</span><br><span class="line">	info := &amp;grpc.UnaryServerInfo&#123;</span><br><span class="line">		Server:     srv,</span><br><span class="line">		FullMethod: &quot;/containerd.services.containers.v1.Containers/Create&quot;,</span><br><span class="line">	&#125;</span><br><span class="line">	handler := func(ctx context.Context, req interface&#123;&#125;) (interface&#123;&#125;, error) &#123;</span><br><span class="line">		return srv.(ContainersServer).Create(ctx, req.(*CreateContainerRequest))</span><br><span class="line">	&#125;</span><br><span class="line">	return interceptor(ctx, in, info, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以最终<code>r, err := c.ContainerService().Create(ctx, container)</code>执行的是<code>service.Create</code>,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//services/containers/service.go:100</span><br><span class="line"></span><br><span class="line">func (s *service) Create(ctx context.Context, req *api.CreateContainerRequest) (*api.CreateContainerResponse, error) &#123;</span><br><span class="line">	return s.local.Create(ctx, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-4-services-ContainersService服务"><a href="#5-3-4-services-ContainersService服务" class="headerlink" title="5.3.4 services.ContainersService服务"></a>5.3.4 <code>services.ContainersService</code>服务</h4><p>而<code>service.Create</code>调用<code>s.local.Create(ctx, req)</code>的方法，又是containerd另一种plugin之间相互调用的方法，即plugin初始化时，直接获取到对应的plugin的实例。<br>可以看到local实际是<code>p, ok := plugins[services.ContainersService]</code>的instance，即依赖了<code>services.ContainersService</code>服务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func init() &#123;</span><br><span class="line">	plugin.Register(&amp;plugin.Registration&#123;</span><br><span class="line">		Type: plugin.GRPCPlugin,</span><br><span class="line">		ID:   &quot;containers&quot;,</span><br><span class="line">		Requires: []plugin.Type&#123;</span><br><span class="line">			plugin.ServicePlugin,</span><br><span class="line">		&#125;,</span><br><span class="line">		InitFn: func(ic *plugin.InitContext) (interface&#123;&#125;, error) &#123;</span><br><span class="line">			plugins, err := ic.GetByType(plugin.ServicePlugin)</span><br><span class="line">			if err != nil &#123;</span><br><span class="line">				return nil, err</span><br><span class="line">			&#125;</span><br><span class="line">			p, ok := plugins[services.ContainersService]</span><br><span class="line">			if !ok &#123;</span><br><span class="line">				return nil, errors.New(&quot;containers service not found&quot;)</span><br><span class="line">			&#125;</span><br><span class="line">			i, err := p.Instance()</span><br><span class="line">			if err != nil &#123;</span><br><span class="line">				return nil, err</span><br><span class="line">			&#125;</span><br><span class="line">			return &amp;service&#123;local: i.(api.ContainersClient)&#125;, nil</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-5-metadata-DB服务"><a href="#5-3-5-metadata-DB服务" class="headerlink" title="5.3.5 metadata.DB服务"></a>5.3.5 <code>metadata.DB</code>服务</h4><p>再去看<code>services.ContainersService</code>服务，发现其是一个本地的<code>metadata.DB</code>，本质上是对<code>bolt.DB</code>的包装。所以最终<code>s.local.Create(ctx, req)</code>就是创建一个<code>metadata.DB</code>信息，并返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func init() &#123;</span><br><span class="line">	plugin.Register(&amp;plugin.Registration&#123;</span><br><span class="line">		Type: plugin.ServicePlugin,</span><br><span class="line">		ID:   services.ContainersService,</span><br><span class="line">		Requires: []plugin.Type&#123;</span><br><span class="line">			plugin.EventPlugin,</span><br><span class="line">			plugin.MetadataPlugin,</span><br><span class="line">		&#125;,</span><br><span class="line">		InitFn: func(ic *plugin.InitContext) (interface&#123;&#125;, error) &#123;</span><br><span class="line">			m, err := ic.Get(plugin.MetadataPlugin)</span><br><span class="line">			if err != nil &#123;</span><br><span class="line">				return nil, err</span><br><span class="line">			&#125;</span><br><span class="line">			ep, err := ic.Get(plugin.EventPlugin)</span><br><span class="line">			if err != nil &#123;</span><br><span class="line">				return nil, err</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			db := m.(*metadata.DB)</span><br><span class="line">			return &amp;local&#123;</span><br><span class="line">				Store:     metadata.NewContainerStore(db),</span><br><span class="line">				db:        db,</span><br><span class="line">				publisher: ep.(events.Publisher),</span><br><span class="line">			&#125;, nil</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-5-CreateContainer执行结束"><a href="#5-3-5-CreateContainer执行结束" class="headerlink" title="5.3.5 CreateContainer执行结束"></a>5.3.5 <code>CreateContainer</code>执行结束</h4><p>至此，<code>CreateContainer</code>创建容器执行结束。</p>
<h3 id="5-4-StartContainer"><a href="#5-4-StartContainer" class="headerlink" title="5.4 StartContainer"></a>5.4 StartContainer</h3><p><code>StartContainer</code>代码调用流程是一样的。这里只列举一些关键点。<br>直接看contaierd中的<code>cri/containerd/pkg/cri/server/container_start.go: criService.StartContainer</code>。<br>各部件之间大概的调用关系为如下，<code>criService.StartContainer</code>从cache中获取<code>container</code>配置，创建一个task，并调用task接口启动容器的进程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">criService.StartContainer--&gt;container.NewTask--&gt;TaskService.Create--&gt;TasksClient.Create--&gt;runtime.Create--&gt;TaskManager.Create--&gt;ShimManager.Start</span><br><span class="line">ShimManager.Start--&gt;NewBundle</span><br><span class="line">ShimManager.Start--&gt;ShimManager.startShim</span><br><span class="line">criService.StartContainer--&gt; Z(task.Start)--&gt;TaskService.Start--&gt;TasksClient.Start--&gt;runtime.Process.Start</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// StartContainer starts the container.</span><br><span class="line">func (c *criService) StartContainer(ctx context.Context, r *runtime.StartContainerRequest) (retRes *runtime.StartContainerResponse, retErr error) &#123;</span><br><span class="line">  ...</span><br><span class="line">  ociRuntime, err := c.getSandboxRuntime(sandbox.Config, sandbox.Metadata.RuntimeHandler)</span><br><span class="line">  ...</span><br><span class="line">  task, err := container.NewTask(ctx, ioCreation, taskOpts...)</span><br><span class="line">  ...</span><br><span class="line">  // Start containerd task.</span><br><span class="line">  if err := task.Start(ctx); err != nil &#123;</span><br><span class="line">    return nil, fmt.Errorf(&quot;failed to start containerd task %q: %w&quot;, id, err)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  return &amp;runtime.StartContainerResponse&#123;&#125;, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-4-1-container-NewTask执行流程"><a href="#5-4-1-container-NewTask执行流程" class="headerlink" title="5.4.1 container.NewTask执行流程"></a>5.4.1 <code>container.NewTask</code>执行流程</h4><h5 id="5-4-1-1-container-NewTask执行流程"><a href="#5-4-1-1-container-NewTask执行流程" class="headerlink" title="5.4.1.1 container.NewTask执行流程"></a>5.4.1.1 <code>container.NewTask</code>执行流程</h5><p><code>container.NewTask</code>中的<code>container</code>为<code>CreateContainer</code>中创建的实例，并缓存了起来，代码来自<code>c.client.NewContainer</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// CreateContainer creates a new container in the given PodSandbox.</span><br><span class="line">func (c *criService) CreateContainer(ctx context.Context, r *runtime.CreateContainerRequest) (_ *runtime.CreateContainerResponse, retErr error) &#123;</span><br><span class="line">    ...</span><br><span class="line">	if cntr, err = c.client.NewContainer(ctx, id, opts...); err != nil &#123;</span><br><span class="line">		return nil, fmt.Errorf(&quot;failed to create containerd container: %w&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	return &amp;runtime.CreateContainerResponse&#123;ContainerId: id&#125;, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看<code>c.client.NewContainer</code>对应的结构体，<code>container.NewTask</code>的代码在<code>container.go:210</code>，主要是调用了<code>TaskService().Create</code>的GRPC接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//container.go:210</span><br><span class="line">func (c *container) NewTask(ctx context.Context, ioCreate cio.Creator, opts ...NewTaskOpts) (_ Task, err error) &#123;</span><br><span class="line">    ...	</span><br><span class="line">	response, err := c.client.TaskService().Create(ctx, request)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//api/services/tasks/v1/tasks.pb.go:1307</span><br><span class="line">func (c *tasksClient) Create(ctx context.Context, in *CreateTaskRequest, opts ...grpc.CallOption) (*CreateTaskResponse, error) &#123;</span><br><span class="line">	out := new(CreateTaskResponse)</span><br><span class="line">	err := c.cc.Invoke(ctx, &quot;/containerd.services.tasks.v1.Tasks/Create&quot;, in, out, opts...)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	return out, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="5-4-1-2-TaskService-Create执行流程"><a href="#5-4-1-2-TaskService-Create执行流程" class="headerlink" title="5.4.1.2 TaskService().Create执行流程"></a>5.4.1.2 <code>TaskService().Create</code>执行流程</h5><p><code>TaskService().Create</code>对应的函数实现在<code>services/tasks/service.go:68 -&gt; service.Create</code>。<br>且此处的local，实际为ID为<code>services.TasksService</code>的plugin，对应的interface为<code>api.TasksClient</code>。<br><code>api.TasksClient</code>同样为GRPC调用，可以直接分析ID为<code>services.TasksService</code>的plugin的struct<code>local.Create</code>代码。<br><code>local.Create</code>最主要的逻辑就是获取当前容器对应的runtime，如果未配置则默认使用v2Runtime，之后调用对应的接口执行<code>Runtimne.Create</code>。<br>可以看到，<code>Runtimne.Create</code>对应的又是一个plugin，此处是通过GetByID获取的对应的plugin：<code>plugin.RuntimePluginV2.&quot;task&quot;</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//services/tasks/service.go:68</span><br><span class="line">func (s *service) Create(ctx context.Context, r *api.StartRequest) (*api.StartResponse, error) &#123;</span><br><span class="line">	return s.local.Create(ctx, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//services/tasks/local.go:156</span><br><span class="line">func (l *local) Create(ctx context.Context, r *api.CreateTaskRequest, _ ...grpc.CallOption) (*api.CreateTaskResponse, error) &#123;</span><br><span class="line">    ...</span><br><span class="line">	rtime, err := l.getRuntime(container.Runtime.Name)</span><br><span class="line">	...</span><br><span class="line">	c, err := rtime.Create(ctx, r.ContainerID, opts)</span><br><span class="line">    ...</span><br><span class="line">	return &amp;api.CreateTaskResponse&#123;</span><br><span class="line">		ContainerID: r.ContainerID,</span><br><span class="line">		Pid:         pid,</span><br><span class="line">	&#125;, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (l *local) getRuntime(name string) (runtime.PlatformRuntime, error) &#123;</span><br><span class="line">	runtime, ok := l.runtimes[name]</span><br><span class="line">	if !ok &#123;</span><br><span class="line">		// one runtime to rule them all</span><br><span class="line">		return l.v2Runtime, nil</span><br><span class="line">	&#125;</span><br><span class="line">	return runtime, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func initFunc(ic *plugin.InitContext) (interface&#123;&#125;, error) &#123;</span><br><span class="line">	config := ic.Config.(*Config)</span><br><span class="line">	runtimes, err := loadV1Runtimes(ic)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	v2r, err := ic.GetByID(plugin.RuntimePluginV2, &quot;task&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-4-1-3-plugin-RuntimePluginV2-quot-task-quot"><a href="#5-4-1-3-plugin-RuntimePluginV2-quot-task-quot" class="headerlink" title="5.4.1.3 plugin.RuntimePluginV2.&quot;task&quot;"></a>5.4.1.3 <code>plugin.RuntimePluginV2.&quot;task&quot;</code></h5><p>可以看到该plugin的注册在<code>runtime/v2/manager.go:50 init</code>函数中，直接看其<code>TaskManager.Create</code>函数。<br>这里又调用了<code>m.manager.Start</code>，这里的<code>m.manager</code>为<code>ShimManager</code>。<br>返回<code>process</code>实例后，又调用<code>shim.Create</code>接口创建了一个<code>shimTask</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// TaskManager wraps task service client on top of shim manager.</span><br><span class="line">type TaskManager struct &#123;</span><br><span class="line">	manager *ShimManager</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Create launches new shim instance and creates new task</span><br><span class="line">func (m *TaskManager) Create(ctx context.Context, taskID string, opts runtime.CreateOpts) (runtime.Task, error) &#123;</span><br><span class="line">	process, err := m.manager.Start(ctx, taskID, opts)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, fmt.Errorf(&quot;failed to start shim: %w&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Cast to shim task and call task service to create a new container task instance.</span><br><span class="line">	// This will not be required once shim service / client implemented.</span><br><span class="line">	shim := process.(*shimTask)</span><br><span class="line">	t, err := shim.Create(ctx, opts)</span><br><span class="line">    ...</span><br><span class="line">	return t, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-4-1-4-ShimManager-Start"><a href="#5-4-1-4-ShimManager-Start" class="headerlink" title="5.4.1.4 ShimManager.Start"></a>5.4.1.4 <code>ShimManager.Start</code></h5><p><code>ShimManager.Start</code>主要逻辑为创建相应的Bundle文件，启动Shim进程，并创建一个<code>shimTask</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Start launches a new shim instance</span><br><span class="line">func (m *ShimManager) Start(ctx context.Context, id string, opts runtime.CreateOpts) (_ ShimProcess, retErr error) &#123;</span><br><span class="line">	bundle, err := NewBundle(ctx, m.root, m.state, id, opts.Spec.Value)</span><br><span class="line">    ...</span><br><span class="line">	shim, err := m.startShim(ctx, bundle, id, opts)</span><br><span class="line">    ...</span><br><span class="line">	shimTask := &amp;shimTask&#123;</span><br><span class="line">		shim: shim,</span><br><span class="line">		task: task.NewTaskClient(shim.client),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if err := m.shims.Add(ctx, shimTask); err != nil &#123;</span><br><span class="line">		return nil, fmt.Errorf(&quot;failed to add task: %w&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return shimTask, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看一下这里的<code>m.startShim</code>，主要就是调用shim的二进制文件，并返回一个该shim的RPC操作client。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">func (m *ShimManager) startShim(ctx context.Context, bundle *Bundle, id string, opts runtime.CreateOpts) (*shim, error) &#123;</span><br><span class="line">    ...</span><br><span class="line">	b := shimBinary(bundle, shimBinaryConfig&#123;</span><br><span class="line">		runtime:      runtimePath,</span><br><span class="line">		address:      m.containerdAddress,</span><br><span class="line">		ttrpcAddress: m.containerdTTRPCAddress,</span><br><span class="line">		schedCore:    m.schedCore,</span><br><span class="line">	&#125;)</span><br><span class="line">	shim, err := b.Start(...)</span><br><span class="line">    ...</span><br><span class="line">	return shim, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (b *binary) Start(ctx context.Context, opts *types.Any, onClose func()) (_ *shim, err error) &#123;</span><br><span class="line">	...</span><br><span class="line">	cmd, err := client.Command(</span><br><span class="line">		ctx,</span><br><span class="line">		&amp;client.CommandConfig&#123;</span><br><span class="line">			Runtime:      b.runtime,</span><br><span class="line">			Address:      b.containerdAddress,</span><br><span class="line">			TTRPCAddress: b.containerdTTRPCAddress,</span><br><span class="line">			Path:         b.bundle.Path,</span><br><span class="line">			Opts:         opts,</span><br><span class="line">			Args:         args,</span><br><span class="line">			SchedCore:    b.schedCore,</span><br><span class="line">		&#125;)</span><br><span class="line">    ...</span><br><span class="line">	client := ttrpc.NewClient(conn, ttrpc.WithOnClose(onCloseWithShimLog))</span><br><span class="line">	return &amp;shim&#123;</span><br><span class="line">		bundle: b.bundle,</span><br><span class="line">		client: client,</span><br><span class="line">	&#125;, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-4-1-5-shimTask-Create"><a href="#5-4-1-5-shimTask-Create" class="headerlink" title="5.4.1.5 shimTask.Create"></a>5.4.1.5 <code>shimTask.Create</code></h5><p><code>shimTask.Create</code>对应的Create又是一个RPC调用，调用的就是上一步返回的可以和shim操作的client。。。<br>再下面的操作，就是对应的shim进程实现的了。kata场景就是<code>containerd-shim-kata-v2</code>实现，runc场景就是containerd自带的<code>containerd-shim-runc-v2</code>来实现的了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	shimTask := &amp;shimTask&#123;</span><br><span class="line">		shim: shim,</span><br><span class="line">		task: task.NewTaskClient(shim.client),</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">func (c *taskClient) Create(ctx context.Context, req *CreateTaskRequest) (*CreateTaskResponse, error) &#123;</span><br><span class="line">	var resp CreateTaskResponse</span><br><span class="line">	if err := c.client.Call(ctx, &quot;containerd.task.v2.Task&quot;, &quot;Create&quot;, req, &amp;resp); err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	return &amp;resp, nil</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<h5 id="5-4-1-6-container-NewTask执行结束"><a href="#5-4-1-6-container-NewTask执行结束" class="headerlink" title="5.4.1.6 container.NewTask执行结束"></a>5.4.1.6 <code>container.NewTask</code>执行结束</h5><p>至此，<code>task, err := container.NewTask(ctx, ioCreation, taskOpts...)</code>的创建task流程走读完成。<br>同时返回了一个task，该task是针对该容器操作的一个封装，可以通过该task对容器进行Kill、Wait、Update等操作。以Kill为例，<code>Task.Update</code>也是调用<code>TaskService().Update</code>来对容器进行操作，和上面的<code>TaskService().Create</code>处理逻辑一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func (t *task) Update(ctx context.Context, opts ...UpdateTaskOpts) error &#123;</span><br><span class="line">	request := &amp;tasks.UpdateTaskRequest&#123;</span><br><span class="line">		ContainerID: t.id,</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">	_, err := t.client.TaskService().Update(ctx, request)</span><br><span class="line">	return errdefs.FromGRPC(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="5-4-2-task-Start任务启动分析"><a href="#5-4-2-task-Start任务启动分析" class="headerlink" title="5.4.2 task.Start任务启动分析"></a>5.4.2 <code>task.Start</code>任务启动分析</h4><h5 id="5-4-2-1-TaskService-Start流程分析"><a href="#5-4-2-1-TaskService-Start流程分析" class="headerlink" title="5.4.2.1 TaskService().Start流程分析"></a>5.4.2.1 <code>TaskService().Start</code>流程分析</h5><p>我么重新来看<code>criService.StartContainer</code>，函数中执行完<code>container.NewTask</code>返回对应的task后，又执行了一个<code>task.Start</code>函数。和上面执行<code>Task.Update</code>流程类似，实际执行了函数：<code>task.go:209 -&gt; task.Start</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// StartContainer starts the container.</span><br><span class="line">func (c *criService) StartContainer(ctx context.Context, r *runtime.StartContainerRequest) (retRes *runtime.StartContainerResponse, retErr error) &#123;</span><br><span class="line">  ...</span><br><span class="line">  ociRuntime, err := c.getSandboxRuntime(sandbox.Config, sandbox.Metadata.RuntimeHandler)</span><br><span class="line">  ...</span><br><span class="line">  task, err := container.NewTask(ctx, ioCreation, taskOpts...)</span><br><span class="line">  ...</span><br><span class="line">  // Start containerd task.</span><br><span class="line">  if err := task.Start(ctx); err != nil &#123;</span><br><span class="line">    return nil, fmt.Errorf(&quot;failed to start containerd task %q: %w&quot;, id, err)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  return &amp;runtime.StartContainerResponse&#123;&#125;, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//task.go:209</span><br><span class="line">func (t *task) Start(ctx context.Context) error &#123;</span><br><span class="line">	r, err := t.client.TaskService().Start(ctx, &amp;tasks.StartRequest&#123;</span><br><span class="line">		ContainerID: t.id,</span><br><span class="line">	&#125;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		if t.io != nil &#123;</span><br><span class="line">			t.io.Cancel()</span><br><span class="line">			t.io.Close()</span><br><span class="line">		&#125;</span><br><span class="line">		return errdefs.FromGRPC(err)</span><br><span class="line">	&#125;</span><br><span class="line">	t.pid = r.Pid</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-4-2-2-TaskService-Start流程分析"><a href="#5-4-2-2-TaskService-Start流程分析" class="headerlink" title="5.4.2.2 TaskService().Start流程分析"></a>5.4.2.2 <code>TaskService().Start</code>流程分析</h5><p>和<code>TaskService().Create</code>执行类似，最终执行的是<code>services/tasks/service.go:72 -&gt; service.Start -&gt; local.Start</code>。<br>亦即最终执行的是 <code>services/tasks/local.gg:246 -&gt; local.Start</code>，这里的<code>local</code>是一个<code>api.TasksClient</code>，最终又是执行RPC接口去启动容器的进程，并检查启动状态。<br>这里的<code>l.getTask</code>是从之前的task缓存获取对应的<code>Task</code>，<code>ShimManager.Start</code>时，会执行<code>shims.Add</code>记录本次contaier的信息，之后就可以通过<code>l.getTask</code>获取到该容器对应的<code>task</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//services/tasks/service.go:72</span><br><span class="line">func (s *service) Start(ctx context.Context, r *api.StartRequest) (*api.StartResponse, error) &#123;</span><br><span class="line">	return s.local.Start(ctx, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//services/tasks/local.go:246</span><br><span class="line">func (l *local) Start(ctx context.Context, r *api.StartRequest, _ ...grpc.CallOption) (*api.StartResponse, error) &#123;</span><br><span class="line">	t, err := l.getTask(ctx, r.ContainerID)</span><br><span class="line">    ...</span><br><span class="line">	p := runtime.Process(t)</span><br><span class="line">    ...</span><br><span class="line">	if err := p.Start(ctx); err != nil &#123;</span><br><span class="line">		return nil, errdefs.ToGRPC(err)</span><br><span class="line">	&#125;</span><br><span class="line">	state, err := p.State(ctx)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, errdefs.ToGRPC(err)</span><br><span class="line">	&#125;</span><br><span class="line">	return &amp;api.StartResponse&#123;</span><br><span class="line">		Pid: state.Pid,</span><br><span class="line">	&#125;, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//runtime/v2/manager.go:158</span><br><span class="line">// Start launches a new shim instance</span><br><span class="line">func (m *ShimManager) Start(ctx context.Context, id string, opts runtime.CreateOpts) (_ ShimProcess, retErr error) &#123;</span><br><span class="line">	bundle, err := NewBundle(ctx, m.root, m.state, id, opts.Spec.Value)</span><br><span class="line">    ...</span><br><span class="line">	shim, err := m.startShim(ctx, bundle, id, opts)</span><br><span class="line">    ...</span><br><span class="line">	// NOTE: temporarily keep this wrapper around until containerd&#x27;s task service depends on it.</span><br><span class="line">	// This will no longer be required once we migrate to client side task management.</span><br><span class="line">	shimTask := &amp;shimTask&#123;</span><br><span class="line">		shim: shim,</span><br><span class="line">		task: task.NewTaskClient(shim.client),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if err := m.shims.Add(ctx, shimTask); err != nil &#123;</span><br><span class="line">		return nil, fmt.Errorf(&quot;failed to add task: %w&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return shimTask, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-4-2-StartContainer执行结束"><a href="#5-4-2-StartContainer执行结束" class="headerlink" title="5.4.2 StartContainer执行结束"></a>5.4.2 <code>StartContainer</code>执行结束</h4><p>至此，一个<code>StartContainer</code>的容器启动流程启动结束。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2013/07/13/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiya1989">
      <meta itemprop="description" content="Good good study,day day up!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="寒竹">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
              <span class="post-sticky-flag" title="置顶">
                <i class="fa fa-thumbtack"></i>
              </span>
            <a href="/2013/07/13/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">


          
            <i class="fa fa-thumbtack"></i>
            <font color=7D26CD>置顶</font>
            <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2013-07-13 20:46:25" itemprop="dateCreated datePublished" datetime="2013-07-13T20:46:25+08:00">2013-07-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-30 12:31:22" itemprop="dateModified" datetime="2022-01-30T12:31:22+08:00">2022-01-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/Hexo/" itemprop="url" rel="index"><span itemprop="name">Hexo</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/PHP/" itemprop="url" rel="index"><span itemprop="name">PHP</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Games/" itemprop="url" rel="index"><span itemprop="name">Games</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<p>摘要-HelloWorld</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2013/07/13/hello-world/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/30/linux_char_dev/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yiya1989">
      <meta itemprop="description" content="Good good study,day day up!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="寒竹">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/30/linux_char_dev/" class="post-title-link" itemprop="url">Linux 字符设备驱动开发</a>
        </h2>

        <div class="post-meta">


          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-30 12:07:11 / 修改时间：16:44:18" itemprop="dateCreated datePublished" datetime="2022-01-30T12:07:11+08:00">2022-01-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/" itemprop="url" rel="index"><span itemprop="name">字符设备</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <span id="more"></span>
<h1 id="Linux-字符设备驱动结构"><a href="#Linux-字符设备驱动结构" class="headerlink" title="Linux 字符设备驱动结构"></a>Linux 字符设备驱动结构</h1><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zqixiao_09/article/details/50839042?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164343808116780357251799%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=164343808116780357251799&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-50839042.nonecase&utm_term=Linux+%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%BB%93%E6%9E%84&spm=1018.2226.3001.4450">cdev 结构体、设备号相关知识解析</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zqixiao_09/article/details/50849735?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164343808116780357251799%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=164343808116780357251799&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-4-50849735.nonecase&utm_term=Linux+%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%BB%93%E6%9E%84&spm=1018.2226.3001.4450">自动创建设备节点</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zqixiao_09/article/details/50850004?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164343808116780357251799%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=164343808116780357251799&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-50850004.nonecase&utm_term=Linux+%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%BB%93%E6%9E%84&spm=1018.2226.3001.4450">file、inode结构体及chardevs数组等相关知识解析</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zqixiao_09/article/details/50850475?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164343808116780357251799%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=164343808116780357251799&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-3-50850475.nonecase&utm_term=Linux+%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%BB%93%E6%9E%84&spm=1018.2226.3001.4450">file_operations 结构体知识解析</a></li>
</ol>
<h1 id="Linux-字符设备驱动开发基础"><a href="#Linux-字符设备驱动开发基础" class="headerlink" title="Linux 字符设备驱动开发基础"></a>Linux 字符设备驱动开发基础</h1><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zqixiao_09/article/details/50850708?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164351608716780265482854%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=164351608716780265482854&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-50850708.nonecase&utm_term=Linux+%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80&spm=1018.2226.3001.4450">编写简单 LED 设备驱动</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zqixiao_09/article/details/50858776?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164351608716780265482854%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=164351608716780265482854&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-50858776.nonecase&utm_term=Linux+%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80&spm=1018.2226.3001.4450">编写简单 PWM 设备驱动</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zqixiao_09/article/details/50858946?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164351608716780265482854%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=164351608716780265482854&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-3-50858946.nonecase&utm_term=Linux+%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80&spm=1018.2226.3001.4450">read()、write() 相关函数解析</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zqixiao_09/article/details/50859302?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164351608716780265482854%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=164351608716780265482854&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-4-50859302.nonecase&utm_term=Linux+%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80&spm=1018.2226.3001.4450">ioctl() 函数解析</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zqixiao_09/article/details/50859505?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164351608716780265482854%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=164351608716780265482854&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-6-50859505.nonecase&utm_term=Linux+%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80&spm=1018.2226.3001.4450">ioremap() 函数解析</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zqixiao_09/article/details/50859759?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164351608716780265482854%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=164351608716780265482854&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-5-50859759.nonecase&utm_term=Linux+%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80&spm=1018.2226.3001.4450">VFS 虚拟文件系统解析</a></li>
</ol>
<h1 id="字符驱动完整示例"><a href="#字符驱动完整示例" class="headerlink" title="字符驱动完整示例"></a>字符驱动完整示例</h1><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lanzhihui_10086/article/details/115446066">file_operations使用示例（实现read/write/ioctl）</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yiya1989</p>
  <div class="site-description" itemprop="description">Good good study,day day up!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yiya1989</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
